-- Migration to restructure catalog with 3 levels: categories -> families -> subfamilies

-- 1. Create/Update Categories table
-- Adding catalog_id to track original JSON IDs (e.g., "1", "2")
ALTER TABLE categories ADD COLUMN IF NOT EXISTS catalog_id text;
ALTER TABLE categories ADD COLUMN IF NOT EXISTS slug text; -- Ensure slug exists if not already

-- 2. Create Families table
CREATE TABLE IF NOT EXISTS families (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    category_id uuid REFERENCES categories(id) ON DELETE CASCADE NOT NULL,
    name text NOT NULL,
    slug text NOT NULL,
    catalog_id text, -- e.g., "1.1"
    display_order integer GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
);

-- Index for better performance
CREATE INDEX IF NOT EXISTS idx_families_category_id ON families(category_id);

-- 3. Create Subfamilies table
CREATE TABLE IF NOT EXISTS subfamilies_new (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    family_id uuid REFERENCES families(id) ON DELETE CASCADE NOT NULL,
    description text NOT NULL, -- Corresponds to JSON description
    is_consumable boolean DEFAULT false,
    catalog_id text, -- e.g., "1.1.1"
    slug text, -- explicit slug if needed, though description is main unique text in JSON
    display_order integer GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
);

-- Index for better performance
CREATE INDEX IF NOT EXISTS idx_subfamilies_new_family_id ON subfamilies_new(family_id);

-- 4. Handle transition from old subfamilies if necessary
-- For now, we are creating a parallel structure. 
-- We might need to drop the old subfamilies table or rename it if we want to replace it entirely.
-- The plan said "Dados existentes... ser√£o apagados".
-- Let's drop the old constraints first if we were to drop table, but strictly speaking,
-- if we want to preserve the table name 'subfamilies' but change its structure, we should migrate.

-- However, the old 'subfamilies' text definition and structure seems different (linked to categories directly).
-- So we should probably DROP the old table and recreate it or RENAME existing one to 'subfamilies_legacy' and rename 'subfamilies_new' to 'subfamilies'.

DO $$ 
BEGIN
    -- If old subfamilies exists and has column category_id (old structure)
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'subfamilies' AND column_name = 'category_id') THEN
        -- Drop dependent constraints if any (e.g. products pointing to subfamilies)
        -- We will need to handle products later. For now, let's just clear data as requested or Alter table.
        -- ALTER TABLE subfamilies DROP CONSTRAINT IF EXISTS ...
        
        -- Easier strategy: Drop old table if empty or just Drop it (User agreed to restructure).
        -- But products might reference it.
        -- Let's check products FK.
        PERFORM 1;
    END IF;
END $$;

-- Depending on constraints, dropping 'subfamilies' might fail if 'products' references it.
-- We must alter 'products' first or drop constraints.
ALTER TABLE products DROP CONSTRAINT IF EXISTS products_subcategory_id_fkey;

-- Now safe to replace subfamilies
DROP TABLE IF EXISTS subfamilies;
ALTER TABLE subfamilies_new RENAME TO subfamilies;

-- 5. Update Products table to reference subfamilies (the new one)
-- The FK is to the same table name 'subfamilies', so we just re-add constraint
ALTER TABLE products 
    ADD CONSTRAINT products_subcategory_id_fkey 
    FOREIGN KEY (subcategory_id) 
    REFERENCES subfamilies(id) 
    ON DELETE SET NULL;

-- 6. Grant permissions (standard Supabase pattern)
ALTER TABLE families ENABLE ROW LEVEL SECURITY;
ALTER TABLE subfamilies ENABLE ROW LEVEL SECURITY;

-- Policies for public read / admin write
CREATE POLICY "Public families are viewable by everyone." ON families FOR SELECT USING (true);
CREATE POLICY "Public subfamilies are viewable by everyone." ON subfamilies FOR SELECT USING (true);

-- Admin policies (using app_role enum check typically)
CREATE POLICY "Admins can insert families" ON families FOR INSERT WITH CHECK (auth.uid() IN (SELECT user_id FROM user_roles WHERE role = 'admin'));
CREATE POLICY "Admins can update families" ON families FOR UPDATE USING (auth.uid() IN (SELECT user_id FROM user_roles WHERE role = 'admin'));
CREATE POLICY "Admins can delete families" ON families FOR DELETE USING (auth.uid() IN (SELECT user_id FROM user_roles WHERE role = 'admin'));

CREATE POLICY "Admins can insert subfamilies" ON subfamilies FOR INSERT WITH CHECK (auth.uid() IN (SELECT user_id FROM user_roles WHERE role = 'admin'));
CREATE POLICY "Admins can update subfamilies" ON subfamilies FOR UPDATE USING (auth.uid() IN (SELECT user_id FROM user_roles WHERE role = 'admin'));
CREATE POLICY "Admins can delete subfamilies" ON subfamilies FOR DELETE USING (auth.uid() IN (SELECT user_id FROM user_roles WHERE role = 'admin'));

